/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cmd

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/GoogleCloudPlatform/db-context-enrichment/internal/config"
	"github.com/GoogleCloudPlatform/db-context-enrichment/internal/database"
	_ "github.com/GoogleCloudPlatform/db-context-enrichment/internal/database/mysql"
	_ "github.com/GoogleCloudPlatform/db-context-enrichment/internal/database/postgres"
	_ "github.com/GoogleCloudPlatform/db-context-enrichment/internal/database/sqlserver"
	"github.com/GoogleCloudPlatform/db-context-enrichment/internal/enricher"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	cfgFile            string
	dryRun             bool
	outputFile         string
	inputFile          string
	updateExistingMode string
)

// Define flags for database connection
var (
	dialect                        string
	host                           string
	port                           int
	username                       string
	password                       string
	dbName                         string
	cloudSQLInstanceConnectionName string
	cloudSQLUsePrivateIP           bool
)

var rootCmd = &cobra.Command{
	Use:   "db_schema_enricher",
	Short: "A tool to enrich database schema with metadata",
	Long: `db_schema_enricher is a CLI tool that helps enrich database schemas
with metadata like column descriptions, example values, and foreign key relationships.`,
	PersistentPreRunE: initFlagsAndConfig,
	RunE:              runAddComments, // Default action is to generate comments
}

// addCommentsCmd represents the addComments command
var addCommentsCmd = &cobra.Command{
	Use:               "add-comments",
	Short:             "Generate SQL for adding comments to database columns based on metadata",
	Long:              `Connects to the database, collects metadata, and generates SQL statements to add column comments. These SQL statements are outputted to a file for review before actual application.`,
	Example:           `./db_schema_enricher add-comments --dialect cloudsqlpostgres --username user --password pass --database mydb --cloudsql-instance-connection-name my-project:my-region:my-instance --out_file ./mydb_comments.sql`,
	PersistentPreRunE: initFlagsAndConfig,
	RunE:              runAddComments,
}

var getCommentsCmd = &cobra.Command{
	Use:     "get-comments",
	Short:   "Get comments from database columns",
	Long:    `Retrieves column comments from the database and outputs them to the terminal or a file.`,
	Example: `./db_schema_enricher get-comments --dialect cloudsqlpostgres --username user --password pass --database mydb --cloudsql-instance-connection-name my-project:my-region:my-instance --out ./mydb_comments.txt`,
	RunE:    runGetComments,
}

var deleteCommentsCmd = &cobra.Command{
	Use:     "delete-comments",
	Short:   "Delete comments added by gemini from database columns",
	Long:    `Deletes the portion of column comments that are within the <gemini> tags, leaving other parts of the comment untouched.`,
	Example: `./db_schema_enricher delete-comments --dialect cloudsqlpostgres --username user --password pass --database mydb --cloudsql-instance-connection-name my-project:my-region:my-instance --dry-run`,
	RunE:    runDeleteComments,
}

var applyCommentsCmd = &cobra.Command{
	Use:     "apply-comments",
	Short:   "Apply comments to database columns from a SQL file",
	Long:    `Reads SQL statements from a specified file and applies them to the database. This is typically used to apply comments generated by the 'add-comments' command.`,
	Example: `db_schema_enricher apply-comments --dialect cloudsqlpostgres --username user --password pass --database mydb --cloudsql-instance-connection-name my-project:my-region:my-instance --in_file ./column_comments.sql`,
	RunE: func(cmd *cobra.Command, args []string) error {
		dbConfig := database.GetConfig()
		if dbConfig == nil {
			return fmt.Errorf("database config is not initialized")
		}

		db, err := database.New(*dbConfig)
		if err != nil {
			log.Println("ERROR: Failed to connect to database:", err)
			return fmt.Errorf("failed to connect to database: %w", err)
		}
		defer db.Close()

		return runApplyComments(cmd, inputFile, db)
	},
}

// initFlagsAndConfig initializes flags and database configuration using command flags and global config.
func initFlagsAndConfig(cmd *cobra.Command, args []string) error {
	cfg := config.GetConfig()

	dbCfg := cfg.Database

	if cmd != nil {
		if cmd.Flags().Changed("dialect") {
			dbCfg.Dialect = dialect
		}
		if cmd.Flags().Changed("host") {
			dbCfg.Host = host
		}
		if cmd.Flags().Changed("port") {
			dbCfg.Port = port
		}
		if cmd.Flags().Changed("username") {
			dbCfg.User = username
		}
		if cmd.Flags().Changed("password") {
			dbCfg.Password = password
		}
		if cmd.Flags().Changed("database") {
			dbCfg.DBName = dbName
		}
		if cmd.Flags().Changed("cloudsql-instance-connection-name") {
			dbCfg.CloudSQLInstanceConnectionName = cloudSQLInstanceConnectionName
		}
		if cmd.Flags().Changed("cloudsql-use-private-ip") {
			dbCfg.UsePrivateIP = cloudSQLUsePrivateIP
		}
		if cmd.Flags().Changed("update_existing") {
			dbCfg.UpdateExistingMode = strings.ToLower(updateExistingMode)
		}
	}

	database.SetConfig(&dbCfg)
	config.SetConfig(cfg)

	return nil
}

func runAddComments(cmd *cobra.Command, args []string) error {
	dbConfig := database.GetConfig()
	if dbConfig == nil {
		return fmt.Errorf("database config is not initialized")
	}

	// Set default output file for add-comments if not provided
	if outputFile == "" {
		outputFile = fmt.Sprintf("%s_comments.sql", dbConfig.DBName)
	}
	// Validate dialect flag
	supportedDialects := []string{"postgres", "cloudsqlpostgres", "mysql", "cloudsqlmysql", "sqlserver", "cloudsqlsqlserver"}
	isValidDialect := false
	for _, supportedDialect := range supportedDialects {
		if dialect == supportedDialect {
			isValidDialect = true
			break
		}
	}
	if !isValidDialect {
		return fmt.Errorf("unsupported dialect: %s (only %s are supported)", dialect, strings.Join(supportedDialects, ", "))
	}

	log.Println("INFO: Starting add-comments operation", "dialect:", dbConfig.Dialect, "database:", dbConfig.DBName)

	db, err := database.New(*dbConfig)
	if err != nil {
		log.Println("ERROR: Failed to connect to database:", err)
		return fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	metadataCollector := enricher.NewMetadataCollector(db, &enricher.DefaultRetryOptions, dryRun)

	ctx := cmd.Context()
	sqlStatements, err := metadataCollector.GenerateCommentSQLs(ctx)
	if err != nil {
		return fmt.Errorf("metadata collection and SQL generation failed: %w", err)
	}

	file, createErr := os.Create(outputFile)
	if createErr != nil {
		return fmt.Errorf("failed to create output file: %w", createErr)
	}
	defer file.Close()

	for _, sqlStmt := range sqlStatements {
		if _, writeErr := file.WriteString(sqlStmt + "\n"); writeErr != nil {
			return fmt.Errorf("failed to write SQL statement to file: %w", writeErr)
		}
	}

	log.Println("INFO: SQL statements to add column comments have been written to:", outputFile)

	if dryRun {
		log.Println("INFO: Add comments operation completed in dry-run mode.  No changes were made to the database.")
		return nil
	}

	// --- User Confirmation ---
	if len(sqlStatements) > 0 {
		fmt.Println("\n-------------------------------------------------------------")
		fmt.Println("Generated SQL statements to add column comments:")

		reader := bufio.NewReader(os.Stdin)
		fmt.Print("Do you want to apply these changes to the database? (yes/no): ")
		text, _ := reader.ReadString('\n')
		action := strings.TrimSpace(strings.ToLower(text))

		if action == "yes" || action == "y" {
			if execErr := db.ExecuteSQLStatements(ctx, sqlStatements); execErr != nil {
				return fmt.Errorf("failed to execute SQL statements to add comments: %w", execErr)
			}
			log.Println("INFO: Successfully added comments to the database.")
		} else {
			log.Println("INFO: Comment addition aborted by user.")
		}
	} else {
		log.Println("INFO: No comments to add.")
	}

	log.Println("INFO: Add comments operation completed.")
	return nil
}

func runApplyComments(cmd *cobra.Command, sqlFilePath string, db *database.DB) error {
	dbConfig := database.GetConfig()
	if dbConfig == nil {
		return fmt.Errorf("database config is not initialized")
	}
	//Set default input file if not provided
	inputFile = sqlFilePath
	if inputFile == "" {
		inputFile = fmt.Sprintf("%s_comments.sql", dbConfig.DBName)
	}
	log.Println("INFO: Starting apply-comments operation from file:", inputFile)

	sqlStatements, err := readSQLStatementsFromFile(inputFile)
	if err != nil {
		return fmt.Errorf("failed to read SQL statements from file: %w", err)
	}

	ctx := cmd.Context()
	if execErr := db.ExecuteSQLStatements(ctx, sqlStatements); execErr != nil {
		return fmt.Errorf("failed to apply comments from SQL file: %w", execErr)
	}

	log.Println("INFO: Apply comments operation completed")
	return nil
}

func readSQLStatementsFromFile(filePath string) ([]string, error) {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	sqlStatements := strings.Split(string(content), ";\n")
	var trimmedStatements []string
	for _, stmt := range sqlStatements {
		trimmedStmt := strings.TrimSpace(stmt)
		if trimmedStmt != "" {
			trimmedStatements = append(trimmedStatements, trimmedStmt)
		}
	}
	return trimmedStatements, nil
}

func runDeleteComments(cmd *cobra.Command, args []string) error {
	dbConfig := database.GetConfig()
	if dbConfig == nil {
		return fmt.Errorf("database config is not initialized")
	}

	if outputFile == "" {
		outputFile = fmt.Sprintf("%s_comments.sql", dbConfig.DBName)
	}

	supportedDialects := []string{"postgres", "cloudsqlpostgres", "mysql", "cloudsqlmysql", "sqlserver", "cloudsqlsqlserver"}
	isValidDialect := false
	for _, supportedDialect := range supportedDialects {
		if dialect == supportedDialect {
			isValidDialect = true
			break
		}
	}
	if !isValidDialect {
		return fmt.Errorf("unsupported dialect: %s (only %s are supported)", dialect, strings.Join(supportedDialects, ", "))
	}

	log.Println("INFO: Starting delete-comments operation", "dialect:", dbConfig.Dialect, "database:", dbConfig.DBName)

	db, err := database.New(*dbConfig)
	if err != nil {
		log.Println("ERROR: Failed to connect to database:", err)
		return fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	metadataCollector := enricher.NewMetadataCollector(db, &enricher.DefaultRetryOptions, dryRun)

	ctx := cmd.Context()
	sqlStatements, err := metadataCollector.GenerateDeleteCommentSQLs(ctx)
	if err != nil {
		return fmt.Errorf("metadata collection and SQL generation for delete comments failed: %w", err)
	}

	file, createErr := os.Create(outputFile)
	if createErr != nil {
		return fmt.Errorf("failed to create output file: %w", createErr)
	}
	defer file.Close()

	for _, sqlStmt := range sqlStatements {
		if _, writeErr := file.WriteString(sqlStmt + "\n"); writeErr != nil {
			return fmt.Errorf("failed to write SQL statement to file: %w", writeErr)
		}
	}
	log.Println("INFO: SQL statements to delete column comments have been written to:", outputFile)

	if dryRun {
		log.Println("INFO: No comments were actually deleted in dry-run mode. Run apply-comments to delete comments.")
		return nil
	}

	if len(sqlStatements) > 0 {
		fmt.Println("\n-------------------------------------------------------------")
		fmt.Println("Generated SQL statements to delete column comments:")

		reader := bufio.NewReader(os.Stdin)
		fmt.Print("Do you want to apply these changes to the database? (yes/no): ")
		text, _ := reader.ReadString('\n')
		action := strings.TrimSpace(strings.ToLower(text))

		if action == "yes" || action == "y" {
			if execErr := db.ExecuteSQLStatements(ctx, sqlStatements); execErr != nil {
				return fmt.Errorf("failed to execute SQL statements to delete comments: %w", execErr)
			}
			fmt.Println("INFO: Successfully deleted gemini comments from the database.")
		} else {
			fmt.Println("INFO: Comment deletion aborted by user.")
		}
	} else {
		fmt.Println("INFO: No gemini comments found to delete.")
	}

	log.Println("INFO: Delete comments operation completed, dry_run:", dryRun)
	return nil
}

func runGetComments(cmd *cobra.Command, args []string) error {
	// Validate dialect flag
	supportedDialects := []string{"postgres", "cloudsqlpostgres", "mysql", "cloudsqlmysql", "sqlserver", "cloudsqlsqlserver"}
	isValidDialect := false
	for _, supportedDialect := range supportedDialects {
		if dialect == supportedDialect {
			isValidDialect = true
			break
		}
	}
	if !isValidDialect {
		return fmt.Errorf("unsupported dialect: %s (only %s are supported)", dialect, strings.Join(supportedDialects, ", "))
	}

	dbConfig := database.GetConfig()
	if dbConfig == nil {
		return fmt.Errorf("database config is not initialized")
	}

	// Set default output file for get-comments if not provided
	if outputFile == "" {
		outputFile = fmt.Sprintf("%s_comments.txt", dbConfig.DBName)
	}

	log.Println("INFO: Starting get-comments operation",
		"dialect:", dialect,
		"database:", dbName,
	)

	db, err := database.New(*dbConfig)
	if err != nil {
		log.Println("ERROR: Failed to connect to database:", err)
		return fmt.Errorf("failed to connect to database: %w", err)
	}
	defer db.Close()

	metadataCollector := enricher.NewMetadataCollector(db, &enricher.DefaultRetryOptions, dryRun)
	ctx := cmd.Context()
	comments, err := metadataCollector.GetComments(ctx)
	if err != nil {
		return fmt.Errorf("failed to retrieve comments: %w", err)
	}

	output := enricher.FormatCommentsAsText(comments)
	if err := enricher.WriteCommentsToFile(output, outputFile); err != nil {
		return fmt.Errorf("failed to write comments to file: %w", err)
	}
	fmt.Printf("Comments written to: %s\n", outputFile)

	log.Println("INFO: Get comments operation completed")
	return nil
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() error {
	return rootCmd.Execute()
}

func init() {
	cobra.OnInitialize(initConfig)

	// Global persistent flags
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "Config file path (default is $HOME/.db_schema_enricher.yaml)")
	rootCmd.PersistentFlags().BoolVar(&dryRun, "dry-run", true, "Enable dry-run mode (no database modifications)")

	// Database connection flags
	rootCmd.PersistentFlags().StringVar(&dialect, "dialect", "", fmt.Sprintf("Database dialect (%s)", strings.Join([]string{"postgres", "mysql", "sqlserver", "cloudsqlpostgres", "cloudsqlmysql", "cloudsqlsqlserver"}, ", ")))
	rootCmd.PersistentFlags().StringVar(&host, "host", os.Getenv("DB_HOST"), "Database host")
	rootCmd.PersistentFlags().IntVar(&port, "port", 0, "Database port") // Default port will be set by viper or dialect defaults
	rootCmd.PersistentFlags().StringVar(&username, "username", os.Getenv("DB_USERNAME"), "Database username")
	rootCmd.PersistentFlags().StringVar(&password, "password", os.Getenv("DB_PASSWORD"), "Database password")
	rootCmd.PersistentFlags().StringVar(&dbName, "database", os.Getenv("DB_NAME"), "Database name")
	rootCmd.PersistentFlags().StringVar(&cloudSQLInstanceConnectionName, "cloudsql-instance-connection-name", os.Getenv("CLOUD_SQL_INSTANCE_CONNECTION_NAME"), "Cloud SQL instance connection name (for Cloud SQL dialects)")
	rootCmd.PersistentFlags().BoolVar(&cloudSQLUsePrivateIP, "cloudsql-use-private-ip", false, "Use private IP for Cloud SQL connection (Cloud SQL)")
	rootCmd.PersistentFlags().StringVar(&updateExistingMode, "update_existing", "overwrite", "Mode to update existing comments ('overwrite' or 'append')")

	// Flags for get-comments command
	getCommentsCmd.Flags().StringVarP(&outputFile, "out_file", "o", "", "File path to save comments to (optional, defaults to <database>_comments.txt)")

	// Flags for add-comments command
	addCommentsCmd.Flags().StringVarP(&outputFile, "out_file", "o", "", "File path to output generated SQL statements (defaults to <database>_comments.sql)")

	// Flags for apply-comments command
	applyCommentsCmd.Flags().StringVarP(&inputFile, "in_file", "i", "", "File path to read SQL statements from (defaults to <database>_comments.sql)")

	deleteCommentsCmd.Flags().StringVarP(&outputFile, "out_file", "o", "", "File path to output generated SQL statements (defaults to <database>_comments.sql)")

	// Add subcommands
	rootCmd.AddCommand(addCommentsCmd)
	rootCmd.AddCommand(getCommentsCmd)
	rootCmd.AddCommand(deleteCommentsCmd)
	rootCmd.AddCommand(applyCommentsCmd)
}

// initConfig reads config file and environment variables.
func initConfig() {
	if cfgFile != "" {
		viper.SetConfigFile(cfgFile) // Use config file from flag
	} else {
		viper.SetConfigName(".db_schema_enricher") // Config file name without extension
		viper.SetConfigType("yaml")
		viper.AddConfigPath("$HOME") // Search config in home directory
	}

	viper.AutomaticEnv() // Read environment variables

	if err := viper.ReadInConfig(); err == nil {
		fmt.Println("Using config file:", viper.ConfigFileUsed())
	}
}
